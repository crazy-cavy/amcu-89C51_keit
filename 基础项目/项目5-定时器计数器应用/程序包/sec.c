/************************************************************************************/
//利用定时器0中断，实现SEG0秒计数
/************************************************************************************/
#include<reg51.h>
code unsigned char seven_seg[10] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};
unsigned char cp,i;                  //声明全局变量
void timer0_isr(void)  interrupt 1      // timer0中断服务函数
{
	TR0 = 0;                     //停止计数
	TL0 = 0x78;                  //TL0重新预置，把63536转化为16进制后的低8位
	TH0 = 0xec;                  // TH0重新预置
	TR0 = 0;                     //开始计数
	cp++;                        // timer0中断1次，变量cp加1
	if(cp == 200)                   //中断200次，时间刚好为1秒
	{
		cp = 0;
		i ++;
	}
	P2 = 0xfe;						//P2输出数码管的位选信号，seg0亮
	if(i == 10) i = 0;
	P0 = seven_seg[i];              // P0输出显示数据
	TR0=1;
}
void timer0_initialize(void)            // timer0中断初始化函数
{
	EA = 0;                       //设置中断允许寄存器IE中的 EA位，关闭中断总开关
	TMOD = 0x01;                  //设置计时器模式控制寄存器，Time0工作在定时方式1,16为定时器
	TR0 = 0;       //设置计时器控制寄存器TCON寄存器的TR0位为0，Timer0停止计数
	TL0 = (65536 - 5000) % 256;	 //设置定时器的低8位初值，计5000个机器周期脉冲就会溢出
	TH0 = (65536 - 5000) / 256;; //设置定时器的高8位初值，假设单片机晶振为12MHz。
									//频率，单片机的机器周期为1微妙，Timer0每1微秒加1
									//计数，加满溢出变产生中断，从计数到中断刚好为5毫秒
	PT0 = 1;                      //设置中断优先次序寄存器IP中的PT0位，Timer0中断优先
	ET0 = 1;                      //设置中断允许寄存器IE中ET0的位，开启中断小开关
	EA = 1;                       //打开中断总开关
	TR0 = 1;                      //开始计数
}
void main (void)
{
	timer0_initialize();               // timer0初始化，为中断做好准备
	while (1);                      //等待中断
}
